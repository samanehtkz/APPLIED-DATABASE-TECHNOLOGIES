# -*- coding: utf-8 -*-
"""Copy of Web App: Final Project Part 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gpzvj32ToEiF6-0LPr_x-JiipQtuRb8w

# Web App: Final Project Part 3
*Group 3: Marissa Reed, Jeff Shen, Samaneh Torkzadeh*

## Data Import
"""

import pandas as pd
import numpy as np

pd.set_option('display.max_columns', None)

df = pd.read_csv('Healthcare Providers.csv')
df.columns = ['fact_service_index','npi','provider_last_name','provider_first_name','provider_mi',
              'provider_credentials','provider_gender','entity_type','nppes_provider_street1',
              'nppes_provider_street2','nppes_provider_city','nppes_provider_zip','nppes_provider_state',
              'nppes_provider_country','provider_type','medicare_participation_indicator','place_of_service',
              'hcpcs_code','hcpcs_description','hcpcs_drug_indicator','line_srvc_cnt','bene_unique_cnt',
              'bene_day_srvc_cnt','average_medicare_allowed_amt','average_submitted_chrg_amt',
              'average_medicare_payment_amt','average_medicare_standardized_amt']

# CLEANING DATA

df['average_medicare_allowed_amt'] = df['average_medicare_allowed_amt'].str.replace(',', '').astype(float)
df['average_submitted_chrg_amt'] = df['average_submitted_chrg_amt'].str.replace(',', '').astype(float)
df['average_medicare_payment_amt'] = df['average_medicare_payment_amt'].str.replace(',', '').astype(float)
df['average_medicare_standardized_amt'] = df['average_medicare_standardized_amt'].str.replace(',', '').astype(float)

df['average_medicare_allowed_amt'] = df['average_medicare_allowed_amt'].round(2)
df['average_submitted_chrg_amt'] = df['average_submitted_chrg_amt'].round(2)
df['average_medicare_payment_amt'] = df['average_medicare_payment_amt'].round(2)
df['average_medicare_standardized_amt'] = df['average_medicare_standardized_amt'].round(2)

df['nppes_provider_zip'] = df['nppes_provider_zip'].fillna('99999999')
df['nppes_provider_zip'] = df['nppes_provider_zip'].astype(str).str[:5]
df['nppes_provider_zip'] = df['nppes_provider_zip'].str.replace('.', '0', regex = True)
df['nppes_provider_zip'] = df['nppes_provider_zip'].astype(int)

dfProviders = df.iloc[:, np.r_[1:8,14:16]]
dfProviders = dfProviders.drop_duplicates(subset='npi')

# Author: Jeff Shen
dfAddresses = df.iloc[:, np.r_[1,8:14]]
dfAddresses = dfAddresses.drop_duplicates(subset='npi')

# Author: Jeff Shen
dfServices = df.iloc[:, 17:20]
dfServices = dfServices.drop_duplicates(subset='hcpcs_code')

# Author: Jeff Shen
dfFactServices = df.iloc[:, np.r_[0:2,16:18,20:27]]

# CREATE DATABASE

import sqlite3

file = "ProviderCostAnalysis.db"
try:
  conn = sqlite3.connect(file)
  print("Database is formed")
except:
  print("Database not formed")

c = conn.cursor()

c.execute('DROP TABLE IF EXISTS Providers;')
c.execute('DROP TABLE IF EXISTS Addresses;')
c.execute('DROP TABLE IF EXISTS Services;')
c.execute('DROP TABLE IF EXISTS FactServices;')

# CREAT TABLES AND ATTRIBUTES

conn = sqlite3.connect('ProviderCostAnalysis.db')
c = conn.cursor()

# Create the tables
c.execute('''CREATE TABLE IF NOT EXISTS Providers (
                npi INTEGER NOT NULL PRIMARY KEY,
                provider_last_name TEXT,
                provider_first_name TEXT,
                provider_mi TEXT,
                provider_credentials TEXT,
                provider_gender TEXT,
                entity_type TEXT,
                provider_type TEXT,
                medicare_participation_indicator TEXT
            )''')
c.execute("CREATE INDEX IF NOT EXISTS index_npi ON Providers (npi)")

c.execute('''CREATE TABLE IF NOT EXISTS Addresses (
                npi INTEGER NOT NULL PRIMARY KEY,
                nppes_provider_street1 TEXT,
                nppes_provider_street2 TEXT,
                nppes_provider_city TEXT,
                nppes_provider_zip INTEGER,
                nppes_provider_state TEXT,
                nppes_provider_country TEXT
            )''')
c.execute("CREATE INDEX IF NOT EXISTS index_npi ON Addresses (npi)")

c.execute('''CREATE TABLE IF NOT EXISTS Services (
                hcpcs_code TEXT NOT NULL PRIMARY KEY,
                hcpcs_description TEXT,
                hcpcs_drug_indicator TEXT
            )''')
c.execute("CREATE INDEX IF NOT EXISTS index_hcpcs_code ON Services (hcpcs_code)")


c.execute('''CREATE TABLE IF NOT EXISTS FactServices (
                fact_service_index INTEGER NOT NULL PRIMARY KEY,
                npi INTEGER,
                place_of_service TEXT,
                hcpcs_code TEXT,
                line_srvc_cnt INTEGER,
                bene_unique_cnt INTEGER,
                bene_day_srvc_cnt INTEGER,
                average_medicare_allowed_amt REAL,
                average_submitted_chrg_amt REAL,
                average_medicare_payment_amt REAL,
                average_medicare_standardized_amt REAL

            )''')
c.execute("CREATE INDEX IF NOT EXISTS index_hcpcs_code ON FactServices (hcpcs_code)")
c.execute("CREATE INDEX IF NOT EXISTS index_npi ON FactServices (npi)")

# Create the relationship tables
c.execute('''CREATE TABLE IF NOT EXISTS Providers_Addresses (
                npi INTEGER,
                FOREIGN KEY (npi) REFERENCES Providers (npi),
                FOREIGN KEY (npi) REFERENCES Address (npi)
            )''')

c.execute('''CREATE TABLE IF NOT EXISTS Providers_FactServices (
                npi INTEGER,
                FOREIGN KEY (npi) REFERENCES Providers (npi),
                FOREIGN KEY (npi) REFERENCES FactServices (npi)
            )''')

c.execute('''CREATE TABLE IF NOT EXISTS FactServices_Services (
                hcpcs_code INTEGER,
                FOREIGN KEY (hcpcs_code) REFERENCES FactServices (hcpcs_code),
                FOREIGN KEY (hcpcs_code) REFERENCES Services (hcpcs_code)
            )''')

dfAddresses.to_sql('Addresses', conn, if_exists='append', index = False)
dfProviders.to_sql('Providers', conn, if_exists='append', index = False)
dfServices.to_sql('Services', conn, if_exists='append', index = False)
dfFactServices.to_sql('FactServices', conn, if_exists='append', index = False)

conn.commit()

providers_df = pd.read_sql_query("SELECT * from Providers", conn)

addresses_df = pd.read_sql_query("SELECT * from Addresses", conn)

services_df = pd.read_sql_query("SELECT * from Services", conn)

factServices_df = pd.read_sql_query("SELECT * from FactServices", conn)

services_df.head()

query =  '''
        SELECT p.npi,
        (p.provider_last_name || " " || p.provider_first_name || "," || p.provider_credentials) as provider_name,
        a.nppes_provider_state,
        s.hcpcs_code,
        s.hcpcs_description,
        fs.place_of_service,
        fs.line_srvc_cnt,
        fs.bene_unique_cnt,
        fs.bene_day_srvc_cnt,
        fs.average_medicare_allowed_amt,
        fs.average_submitted_chrg_amt,
        fs.average_medicare_payment_amt,
        fs.average_medicare_standardized_amt
        FROM FactServices fs
        JOIN Providers p on p.npi = fs.npi
        JOIN Addresses a ON fs.npi = a.npi
        JOIN Services s ON fs.hcpcs_code = s.hcpcs_code
        limit 5
    '''

c.execute(query)
result = c.fetchall()
for row in result:
    print(row)



######################### APP

import streamlit as st
import sqlite3
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from PIL import Image

import warnings
warnings.filterwarnings('ignore')


st.set_page_config(layout="wide")

st.title('Provider Cost Analysis Dashboard')

menu = ['Home', 'Comparision Analysis', 'Provider Analysis', 'Cost Analysis', 'Technical Background', 'About']
choice = st.sidebar.selectbox('Menu', menu)

@st.cache_data
def load_data():
    # Connect to SQLite database
    conn = sqlite3.connect('ProviderCostAnalysis.db')
    c = conn.cursor()

    # Query the database for service descriptions
    service_descriptions = pd.read_sql_query("SELECT DISTINCT hcpcs_description from Services", conn)
    state_list = pd.read_sql_query("SELECT DISTINCT nppes_provider_state from Addresses", conn)
    # Query the data
    query = f'''
         SELECT p.npi,
        (p.provider_last_name || " " || p.provider_first_name || "," || p.provider_credentials) as provider_name,
        a.nppes_provider_state,
        s.hcpcs_code,
        s.hcpcs_description,
        fs.place_of_service,
        fs.line_srvc_cnt,
        fs.bene_unique_cnt,
        fs.bene_day_srvc_cnt,
        fs.average_medicare_allowed_amt,
        fs.average_submitted_chrg_amt,
        fs.average_medicare_payment_amt,
        fs.average_medicare_standardized_amt
        FROM FactServices fs
        JOIN Providers p on p.npi = fs.npi
        JOIN Addresses a ON p.npi = a.npi
        JOIN Services s ON fs.hcpcs_code = s.hcpcs_code
    '''
    data = pd.read_sql_query(query, conn)

    # Close the database connection
    conn.close()

    return service_descriptions, state_list, data

# Load the data
service_descriptions, state_list, data = load_data()

if choice == 'Home':
    st.subheader('Project Summary')
    st.write('Our project will develop an intuitive dashboard powered by a SQL database that analyzes medical cost based on the location, provider, and service. This will utilize a dataset from Kaggle containing healthcare providers across different demographics to allow for target users to make informed data-driven business decisions.')
    st.write('\n')
    st.subheader('Project Description')
    st.write('Utilizing a dataset that captures provider costs and geographical locations, our team plans to develop an online web application that analyzes provider costs based on location, provider, and service. This tool is aimed at individuals and organizations of all sizes that depend on third-party service providers and are keen on using data to optimize costs, enhance strategic planning, detect fraud, and improve negotiation tactics. This innovative solution fills a unique gap in the market, providing location-specific cost trends for better operational and financial decision-making.')
    st.write('\n')
    st.write('The proposed location-based provider cost prediction dashboard is highly beneficial for optimizing costs and enhancing financial planning. By comparing provider costs across different locations, companies can select providers that offer the best value, thus improving budgeting efficiency. The dashboard will also contribute to strategic decision-making, guiding where to expand or reduce operations based on cost trends. Additionally, the analysis can give organizations an upper hand during contract negotiations with providers. Ultimately, this tool will provide key insights that enhance cost efficiency, enable better strategic planning, and strengthen negotiation capabilities.\
             There are similar databases and datasets within the Agency for Healthcare Research and Quality (AHRQ) HCUP databases. This one is different because it is just based on cost, location, and provider while the HCUP database takes into account all charges that a patient incurs in a hospital, payor source, discharge status, and severity. We are looking at specific charges for a specific service, rather than the entire stay.')
    st.write('\n')
    st.write('The dataset we are using was originally collected and published by Centers for Medicare and Medicaid Services (CMS) and last updated September 22, 2020, found at the following link here. The publication of this dataset by CMS provides public transparency into providers and healthcare costs. The raw csv file is 23.36 megabytes, 27 columns, and contains over a hundred thousand unique records. The columns include detailed information into provider, location, time and duration of service, type of service, and average charges and insurance payouts. This dataset was eventually uploaded onto Kaggle as an exercise to detect fraud among providers.The Kaggle url is attached in the following hyperlink.')

elif choice == 'Comparision Analysis':

    st.subheader('Comparision between Indiana versus other states per service')

    # Let user select a service
    service_choice = st.selectbox('Select a Service', service_descriptions['hcpcs_description'].tolist())

    # Filter the data for the chosen service
    service_data = data[data['hcpcs_description'] == service_choice]

    # Check if the filtered data is empty
    if not service_data.empty:

        # Calculate average cost for each state
        avg_cost_per_state = service_data.groupby('nppes_provider_state')['average_submitted_chrg_amt'].mean().sort_values()

        # Get the top 5, bottom 5 and Indiana
        comparison_states = pd.concat([avg_cost_per_state.head(5), avg_cost_per_state.tail(5), avg_cost_per_state.loc[avg_cost_per_state.index == 'IN']])

        # Create a subplot grid for the plots
        fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(15, 10))
        plt.tight_layout()

        # Create a barplot for comparison on the right
        sns.barplot(x=comparison_states.index, y=comparison_states.values, ax=ax)
        ax.set_title(f"Cost Comparison for {service_choice} in Indiana and Other States",  wrap = True)
        plt.ylabel('Average Submitted Charge Amount (USD)')
        plt.xticks(rotation=90)
        # Display the plot
        st.pyplot(fig)

    else:
        st.write("No data available for this service.")
elif choice == 'Provider Analysis' :

    st.subheader('Comparison between providers with selected state and service')
     # Let user select a service
    service_choice = st.selectbox('Select a Service', service_descriptions['hcpcs_description'].tolist())
    #Let user select a state
    State_choice = st.selectbox('Select a State', state_list['nppes_provider_state'].tolist())
        # Filter the data for the chosen service

    service_state_data = data[(data['hcpcs_description'] == service_choice) & (data['nppes_provider_state'] == State_choice)]
    if not service_state_data.empty:

        # Calculate average cost for per provider
        avg_cost_per_npi = service_state_data.groupby('provider_name')['average_submitted_chrg_amt'].mean().sort_values()

        comparison = pd.concat([avg_cost_per_npi.head(5), avg_cost_per_npi.tail(5)])
        # Create a subplot grid for the plots
        fig, (ax) = plt.subplots(nrows=1, ncols=1, figsize=(16, 6))
        plt.tight_layout()


        sns.barplot(x=comparison.index, y=comparison.values, ax=ax)
        ax.set_title(f"Cost Comparison for {service_choice}", wrap = True)
        plt.xticks(rotation=90)
        st.pyplot(fig)
        st.write("Graph displays average submitted charge by provider for the selected service of intended state. The graph shows the 5 providers who had the top average charge amount and the 5 providers who had the least average charge amount.")


elif choice == 'Cost Analysis':

    st.subheader('Boxplots of relevent costs per service')

    # Let user select a service
    service_choice = st.selectbox('Select a Service', service_descriptions['hcpcs_description'].tolist())

    # Filter the data for the chosen service
    service_data = data[data['hcpcs_description'] == service_choice]

    # Check if the filtered data is empty
    if not service_data.empty:

        # Calculate average cost for each state
        avg_cost_per_state = service_data.groupby('nppes_provider_state')['average_medicare_payment_amt'].mean().sort_values()

        # Get the top 5, bottom 5 and Indiana
        comparison_states = pd.concat([avg_cost_per_state.head(5), avg_cost_per_state.tail(5), avg_cost_per_state.loc[avg_cost_per_state.index == 'IN']])

        # Create a subplot grid for the plots
        fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(20, 10))
        plt.tight_layout()
        # Create a boxplot for cost on the left
        costs = ['average_medicare_payment_amt', 'average_medicare_allowed_amt', 'average_medicare_standardized_amt']
        sns.boxplot(x = 'variable', y = 'value', data=pd.melt(service_data[costs]), ax=ax1)
        ax1.set_title(f"Cost Distribution for {service_choice}", wrap = True)
        # Create a barplot for comparison on the right
        costs = ['average_submitted_chrg_amt']
        sns.boxplot(x = 'variable', y = 'value', data=pd.melt(service_data[costs]), ax=ax2)
        ax2.set_title(f"Cost Distribution for {service_choice}", wrap = True)
        # Display the plot
        st.pyplot(fig)

    else:
        st.write("No data available for this service.")

elif choice == 'Technical Background':
    st.subheader('Technical Background')
    st.write('This portion of the webapp contains a summary of the design and implementation of our database. The database was created with SQlite in python and the webapp is coded with the streamlit library in python')
    st.subheader('Schema for the database')
    image = Image.open('databaseSchema.png')
    st.image(image)
    st.subheader('Providers Table')
    st.write('The providers table contains information related to the provider such as their name, their NPI (an individual identification for each provider), their credentials, gender, etc. This table can be linked in a one to one relationship to the Addresses table and a one to many to the Fact Services Table.')
    st.write('Npi : Integer: primary key (unique identifier for each provider)')
    st.write('Provider_last_name: text')
    st.write('Provider_first_name: text')
    st.write('Provider_mi: text (middle initial)')
    st.write('Provider_credentials: text')
    st.write('Provider_gender: text')
    st.write('Entity_type: text (whether the NPI is an individual or organization)')
    st.write('Provider_type: text (what type of medicine the provider practices)')
    st.write('Medicare_participation_indicator:text')
    st.write('\n')
    st.subheader('Addresses Table')
    st.write('The addresses table contains the address that corresponds to the NPI of each provider.')
    st.write('npi :integer: Primary key (used to link to the providers table')
    st.write('nppes_provider_street1 : text')
    st.write('Nppes_provider_street2: text')
    st.write('Nppes_provider_city : text')
    st.write('Nppes_provider_zip : int')
    st.write('Nppes_provider_state : text')
    st.write('Nppes_provider_country:text')
    st.write('\n')
    st.subheader('Services Table')
    st.write('The Services table contains information relating to the service such as code, description, and drug indicator. It can be linked in a one to many relationship to the Fact Services. ')
    st.write('hcpcs_code : text : primary key (connects to FactServices)')
    st.write('hcpcs_description : text')
    st.write('hcpcs_drug_indicator : text')
    st.write('\n')
    st.subheader('Fact Services Table')
    st.write('The Fact Services table contains all the information about the services that each NPI provided. This will have how many beneficiaries received that particular service from that provider, how much that provider charged for that service, how much medicare typically allows,  service lines etc. This table will allow us complete analysis on differences in charges between providers and states. ')
    st.write('fact_service_index INTEGER NOT NULL PRIMARY KEY (index to allow for unique identifier of provider with service provided)')
    st.write('npi INTEGER')
    st.write('place_of_service TEXT (where service was provided ex: O- office F-faciltiy)')
    st.write('hcpcs_code TEXT (code used to identify service links to services table)')
    st.write('line_srvc_cnt INTEGER (how many lines of services are involved in procedure)')
    st.write('bene_unique_cnt INTEGER (how many beneficiaries received service)')
    st.write('bene_day_srvc_cnt INTEGER (how many days beneficiaries spent in hospital)')
    st.write('average_medicare_allowed_amt REAL (avg amount medicare allows per service in specific area)')
    st.write('average_submitted_chrg_amt REAL (avg amount provider charged for service)')
    st.write('average_medicare_payment_amt REAL (avg amount medicare paid)')
    st.write('average_medicare_standardized_amt REAL (avg amount standardized across providers)')
    st.write('\n')
    st.subheader('Database Design Constraints')
    st.write('​​In designing our database, there are several constraints we want to enforce to ensure data integrity for the end user. Listed below are some key constraints we are considering.')
    st.write('\n')
    st.write('Uniqueness in primary key: We will want to enforce uniqueness in the ‘Providers’, ‘Addresses’, and ‘Services’ tables. Primary keys for these tables are defined as ‘npi’ and ‘hcpcs_code’ which can be seen from the schema. The ‘FactServices’ table can have repeats due to lots of combinations of providers and services that they offer and so uses an index as a primary key instead.')
    st.write('\n')
    st.write('No null values for important fields: Certain fields are crucial for our analysis and should not be null. These fields include ‘npi’, ‘provider_last_name’, ‘provider_city’, ‘provider_state’, ‘hcpcs_code’, and ‘average_medicare_allowed_amt’. Other fields could potentially be allowed to have null values, like ‘provider_mi’ as not all providers will have a middle initial.')
    st.write('\n')
    st.write('Referential integrity: As we have already added the foreign key references, the database will ensure that any value in the ‘npi’ field of ‘Providers_Addresses’, ‘Providers_FactServices’ and ‘hcpcs_code’ in ‘FactServices_Services’ match the values in the ‘Providers’, ‘FactServices’ and ‘Services’ tables respectively.')
    st.write('\n')
    st.write('Range constraints: Some numerical fields will have range constraints. For instance, the ‘average_medicare_allowed_amt’ would not really make sense as a negative value and could potentially be constrained to be a positive number. We could use a code snippet similar to below to do this.')

elif choice == 'About':
    st.subheader('About Us')
    st.write('1. Samaneh Torkzadeh')
    st.write('Currently a grad student at IU Bloomington focusing on Data Science - Data Visualisation Domain. The APPLIED DATABASE TECHNOLOGIES class taught me what data can do in many fields and how important it is to the modern world. This web app shows you a sneek peek of its powerful techniques regarding relational database.')
    st.write('\n')
    st.write('2. Jeff Shen')
    st.write('Jeff Shen is a graduate student currently working on his masters\
              degree in Data Science at IU Bloomington. This applied database class has given him a much better\
                  understanding of CRUD operations on relational and non-relational databases,\
                      and he is hoping on applying these various techniques learned to\
                          his future studies as well as professional career.\
                          In his spare time, Jeff enjoys indoor bouldering, watercolor, and playing video games.')
    st.write('\n')
    st.write('3. Marissa Reed')
    st.write('I am a data scientist for HCA Healthcare and a grad student at IU Bloomington. The APPLIED DATABASE TECHNOLOGIES class has taught me how to use more databases and in a different languages than I previously knew and the inner workings of the databases. Our app uses a relational database to help the consumer analyze and visualize the data.')
    st.write('\n')